# 广度优先搜索(BFS)

## 定义

广度优先搜索(BFS)是一种图搜索算法，类似于二叉树的层序遍历算法。基本思想是：首先访问起始顶点 `v` ，接着由 `v` 出发，依次访问 `v` 的各个未曾访问过的邻接顶点 `w1` 、 `w2` 、 `w3` 、…、 `wi` ，然后依次从 `w1` 、 `w2` 、 `w3` 、…、 `wi` 出发访问它们的邻接顶点，如此继续下去，直到图中所有和顶点 `v` 有路径相通的顶点都被访问到。若此时图中尚有顶点未被访问，则另选图中一个未曾被访问的顶点作起始点，重复上述过程，直到图中所有顶点都被访问到为止。

Dijkstra 单源最短路径算法是基于广度优先搜索的，但是广度优先搜索并不是单源最短路径算法，因为广度优先搜索不是以边的权值来确定最短路径的。
Prim 最小生成树算法也是基于广度优先搜索的，但是广度优先搜索并不是最小生成树算法，因为广度优先搜索不是以边的权值来确定最小生成树的。

换句话说，广度优先搜索是一种以顶点为中心的搜索算法，是一种分层的查找过程。它的搜索路径是以层次为基础的，即先访问的顶点的邻接顶点优先于后访问的顶点的邻接顶点。每向前走一步可能访问一批顶点，不像深度优先搜索那样有回退的情况，因此它不是一个递归的过程。为了实现逐层的访问，广度优先搜索需要借助一个队列来实现，以记忆正在访问的顶点的下一层顶点。

广度优先搜索算法的伪代码如下：

```cpp
bool visited[MAX_VERTEX_NUM];               // 访问标志数组

void BFSTransverse(Graph G) {               // 广度优先搜索遍历图G
    for (int i = 0; i < G.vexnum; i++)      // 访问标志数组初始化
        visited[i] = false;                 // 所有顶点的访问标志设置为未访问
    InitQueue(Q);                           // 初始化辅助队列
    for (int i = 0; i < G.vexnum; i++)      // 依次检查每个顶点
        if (!visited[i])                    // 若顶点i未访问
            BFS(G, i);                      // 从顶点i开始广度优先搜索
}

void BFS(Graph G, int v) {                  // 从顶点v开始广度优先搜索
    visit(v);                               // 访问顶点v
    visited[v] = true;                      // 设置访问标志
    EnQueue(Q, v);                          // 顶点v入队列
    while (!QueueEmpty(Q)) {                // 队列不空
        DeQueue(Q, u);                      // 队头元素出队列并置为u
        for (w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
            if (!visited[w]) {              // w为u的尚未访问的邻接顶点
                visit(w);                   // 访问顶点w
                visited[w] = true;          // 设置访问标志
                EnQueue(Q, w);              // 顶点w入队列
            }
    }
}
```

辅助数组 `visited[]` 用于标记顶点是否被访问过，其初始状态为 `false` ，表示所有顶点都未被访问过。函数 `BFSTransverse()` 用于遍历图 `G` ，检查每个顶点是否被访问过，若未被访问过，则调用 `BFS()` 函数从该顶点开始广度优先搜索。函数 `BFS()` 从顶点 `v` 开始广度优先搜索，首先访问顶点 `v` ，然后将顶点 `v` 入队列，接着从队列中取出一个顶点 `u` ，访问顶点 `u` 的所有未被访问过的邻接顶点，并将这些邻接顶点入队列，直到队列为空。

## BFS 算法的性能分析

无论是邻接表还是邻接矩阵的存储方式，BFS 算法都需要借助一个辅助队列 Q，n 个顶点均需要入队列一次，在最坏的情况下，空间复杂度为 `O(|V|)`。

采用邻接表存储方式时，每个顶点均需要搜索一次（或入队一次），故时间复杂度为 `O(|V|)` ，在搜索任一顶点的邻接点时，每条边至少访问一次，故时间复杂度为 `O(|E|)` ，算法总的时间复杂度为 `O(|V|+|E|)` 。而采用邻接矩阵存储方式时，查找每个顶点所需的时间为 `O(|V|)` ，而每个顶点均需要搜索一次（或入队一次），故时间复杂度为 `O(|V|^2)` 。

## BFS 算法求解单源最短路径问题

若图 `G = (V, E)` 为非带权图，定义从顶点 `u` 到顶点 `v` 的最短路径 `d(u, v)` 为顶点 `u` 到顶点 `v` 的任何路径中最少边数。
广度优先搜索算法可以求解非带权图的单源最短路径问题，这是由于广度优先搜索算法的特性：从起始顶点开始，每次访问的顶点都是离起始顶点最近的顶点的性质决定的。因此当访问到目标顶点时，所经过的路径就是最短路径。

BFS 算法求解单源最短路径问题的算法代码如下：

```cpp
void BFS(Graph G, int u){               // 从顶点u开始广度优先搜索
    for (int i = 0; i < G.vexnum; i++)
        d[i] = Inf;                     // 初始化d[]为无穷大
    visited[u] = true; d[u] = 0         // 设置访问标志
    EnQueue(Q, u);
    while (!QueueEmpty(Q)){             // BFS算法主过程
        DeQueue(Q, u);                  // 队头元素出队列并置为u
        for (w = FirstAdjVex(G, u); w >= 0; w = NextAdjVex(G, u, w))
            if (!visited[w]){           // w为u的尚未访问的邻接顶点
                visited[w] = true;      // 设置访问标志
                d[w] = d[u] + 1;        // 路径长度加1
                EnQueue(Q, w);          // 顶点w入队列
            }
    }
}
```

## 广度优先生成树
