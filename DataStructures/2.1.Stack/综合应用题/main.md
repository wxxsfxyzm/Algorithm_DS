# 综合应用题

1. 有五个元素，其入栈顺序为 ABCDE 在各种可能的出栈顺序中，第一个出栈元素为 C 且
   第二个出栈元素为 D 的出栈序列有哪几个？ CD 出栈后的状态如右图所示。 此时有如
   下三种操作：

    - ① E 进栈后出栈，出栈序列为 CDEBA；
    - ② B 出栈，E 进栈后出栈，出栈序列为 CDBEA；
    - ③ B 出栈，A 出栈，E 进栈后出栈，出栈序列为 CDBAE。

    所以，CD 出栈后的状态有三种操作，以 CD 开头的出栈序列有 CDEBA, CDBEA, CDBAE
    三种。

2. 若元素的进栈序列为 ABCDE，运用栈操作，能否得到出栈序列 BCAED 和 DBACE？为什么
   ？

    - 可以得到 BCAED

3. 假设以 I 和 O 分别表示入栈和出栈操作，栈的初态和终态均为空，入栈和出栈的操作
   序列可表示为仅由 I 和 O 组成的序列，可以操作的序列称为合法序列，否则称为非法
   序列。

    1. 下面所示的序列中，哪些是合法序列？ A. IOIIOIOO B. IOOIOIIO C. IIIOIOIO D.
       IIIOOIOO
    2. 通过对 1. 的分析，写出一个算法，判定所给的操作序列是否合法。若合法，返回
       true，否则返回 false（假定被判定的操作序列已存入一维数组中）。

4. 设单链表的表头指针为 L，结点结构由 data 和 next 两个域组成，其中 data 域为字
   符型。设计一个算法，判断该链表的全部 n 个字符是否中心对称。例如 xyx，xyyx 都
   是中心对称的。

    - 算法思想：使用栈来判断链表中的数据是否中心对称。让链表的前一半元素依次进栈
      ，在处理链表的后一半元素时，当访问到链表的一个元素后，就从栈中弹出一个元素
      ，将这两个元素进行比较，直至链表尾。这时若栈是空栈，则得出链表中心对称的结
      论；否则，当链表的一个元素与栈中弹出元素不等时，结论为链表非中心对称，结束
      算法的执行。

    - 算法实现：

    ```c
    int dc(LinkList L, int n){
    // L 是带头结点的n个元素单链表，本算法判断链表是否是中心对称
    // 返回值：若是中心对称返回1，否则返回0
      LinkStack s; ElemType e;
        int i;                      // 计数器
        char s[n/2];                // s 为字符栈
        p = L->next;                // p 指向链表的第一个结点
        for(i=0; i<n/2; i++){       // 将链表的前一半元素进栈
          s[i] = p->data;
          p = p->next;
        }
        i--;
        if(n%2==1) p = p->next;     // 若 n 为奇数，跳过中间结点
        while(p!=NULL && p->data==s[i]){
          p = p->next;
          i--;
        }
        if(i==-1) return 1;         // 若栈空，说明链表中心对称
        else return 0;              // 否则，链表非中心对称
    }
    ```

    算法先将“链表的前一半”元素（字符）进栈。当 n 为偶数时，前一半和后一半元素的
    个数相同；当 n 为奇数时，链表中心结点的字符不需要比较，移动链表指针到下一字
    符开始比较。比较过程中遇到不相等时，立即退出 while 循环，不必在进行比较。

    本题也可以先将单链表中的元素全部入栈，然后扫描单链表进行比较，直到比较到链表
    尾为止，但算法需要扫描两次单链表 L，效率上不及本算法高。

5. 设有两个栈 s1，s2 都采用顺序栈方式，并共享一个存储区[0,...,maxsize-1]，为尽量
   利用空间，减少溢出的可能，可采用栈顶相向，迎面增长的存储方式。试设计 s1，s2
   有关出栈和入栈的操作算法。

    - 算法思想：两个栈共享向量空间，将两个栈的栈底设置在向量两端，初始时，s1 栈
      顶指针为-1，s2 栈顶指针为 maxsize，两个栈的栈顶指针相向而行，当 s1 栈顶指
      针与 s2 栈顶指针相邻时，栈满。两个栈顶相向、迎面增长，栈顶指针指向栈顶元素
      。
    - 结构定义：

    ```c
    #define maxsize 100          // 栈的最大长度
    #define ElemType int         // 栈元素的类型

    typedef struct
    {
       ElemType stack[maxsize];  // 存放栈中元素的一维数组
       int top[2];               // 两个栈的栈顶指针
    }stk;

    stk s;                       // 定义一个共享栈
    ```

    本题的关键在于，两个栈入栈和退栈的栈顶指针的计算。s1 栈是通常意义下的栈；而
    s2 栈入栈操作时，其栈顶指针左移（减 1），退栈时，栈顶指针右移（加 1）。 此外
    ，对于所有栈的操作，都要注意“入栈判满，出栈判空”的检查

    - 入栈操作

    ```c
    int push(int i, ElemType x){
      // 入栈操作，i为栈号，i=0表示s1栈，i=1表示s2栈，x为要入栈的元素
      // 返回值：入栈成功返回1，否则返回0
      if(i<0 || i>1){
        printf("栈号输入错误\n");
        exit(0);
      }
      if(s.top[1]-s.top[0]==1){
        printf("栈满\n");
        return 0;
      }
      switch(i){
        case 0: s.stack[++s.top[0]]=x; break;
        case 1: s.stack[--s.top[1]]=x; break;
      }
      return 1;
    }
    ```

    - 出栈操作

    ```c
    ElemType pop(int i){
    // 出栈操作，i为栈号，i=0表示s1栈，i=1表示s2栈
    // 返回值：出栈成功返回出栈元素，否则返回-1
      if(i<0 || i>1){
         printf("栈号输入错误\n");
         exit(0);
      }
      switch(i){
        case 0:
          if(s.top[0]==-1){
            printf("栈空\n");
            return -1;
          }
          return s.stack[s.top[0]--];
            break;
        case 1:
          if(s.top[1]==maxsize){
            printf("栈空\n");
            return -1;
          }
          return s.stack[s.top[1]++];
            break;
      }
    }
    ```
