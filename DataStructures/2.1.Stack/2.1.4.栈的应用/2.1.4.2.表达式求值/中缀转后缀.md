# 中缀转后缀的过程

## 原题描述

【2012 统考真题】已知操作符包括 `+`、`-`、`*`、`/`、`(` 和 `)`。将中缀表达式 `a+b-a*((c+d)/e-f)+g` 转换为等价的后缀表达式 `ab+acd+e/f-*-g+` 时，用栈来存放暂时还不能确定运算次序的操作符。栈初始时为空，转换过程中同时保存在栈中的操作符的最大个数是：
A. 5
B. 7
C. 8
D. 11

## 解析

本题考查的是栈在中缀表达式转化为后缀表达式中的应用。将中缀表达式 `a+b-a*((c+d)/e-f)+g` 转换为相应的后缀的表达式，需要根据操作符 `<op>` 的优先级来进行栈的变化，可以用 `icp` 来表示当前扫描到的运算符 `ch` 的优先级，该运算进栈后的优先级为 `isp`，则运算符的优先级如下表所示[isp 是栈内优先(in stack priority)数，icp 是栈外优先(in coming priority)数]

| operator | `#` | `(` | `*`,`/` | `+`,`-` | `)` |
| :------: | :-: | :-: | :-----: | :-----: | :-: |
|   isp    |  0  |  1  |    5    |    3    |  6  |
|   icp    |  0  |  6  |    4    |    2    |  1  |

为了表示表达式结束，可以在表达式后面加上 `#`。

具体转换过程如下：

| 步骤 | 扫描项 | 项类型 |             动作              | 栈内内容 | 输出 |    后缀表达式     |
| :--: | :----: | :----: | :---------------------------: | :------: | :--: | :---------------: |
|  0   |        |        |          栈底加 `#`           |   `#`    |      |                   |
|  1   |  `a`   | 操作数 |             输出              |   `#`    | `a`  |        `a`        |
|  2   |  `+`   | 操作符 |    isp(`#`)<icp(`+`)，进栈    |   `#+`   |      |        `a`        |
|  3   |  `b`   | 操作数 |             输出              |   `#+`   | `b`  |       `ab`        |
|  4   |  `-`   | 操作符 | isp(`+`)>icp(`-`)，出栈并输出 |   `#`    | `+`  |       `ab+`       |
|  5   |        | 操作符 |    isp(`#`)<icp(`-`)，进栈    |   `#-`   |      |       `ab+`       |
|  6   |  `a`   | 操作数 |             输出              |   `#-`   | `a`  |      `ab+a`       |
|  7   |  `*`   | 操作符 |    isp(`-`)<icp(`*`)，进栈    |  `#-*`   |      |      `ab+a`       |
|  8   |  `(`   | 操作符 |    isp(`*`)<icp(`(`)，进栈    |  `#-*(`  |      |      `ab+a`       |
|  9   |  `(`   | 操作符 |   isp(`()`)<icp(`(`)，进栈    | `#-*((`  |      |      `ab+a`       |
|  10  |  `c`   | 操作数 |             输出              | `#-*((`  | `c`  |      `ab+ac`      |
|  11  |  `+`   | 操作符 |    isp(`(`)<icp(`+`)，进栈    | `#-*((+` |      |      `ab+ac`      |
|  12  |  `d`   | 操作数 |             输出              | `#-*((+` | `d`  |     `ab+acd`      |
|  13  |  `)`   | 操作符 | isp(`+`)>icp(`)`)，出栈并输出 | `#-*((`  | `+`  |     `ab+acd+`     |
|  14  |        |        | isp(`(`)==icp(`)`)，直接出栈  |  `#-*(`  |      |     `ab+acd+`     |
|  15  |  `/`   | 操作符 |    isp(`(`)<icp(`/`)，进栈    | `#-*(/`  |      |     `ab+acd+`     |
|  16  |  `e`   | 操作数 |             输出              | `#-*(/`  | `e`  |    `ab+acd+e`     |
|  17  |  `-`   | 操作符 | isp(`/`)>icp(`-`)，出栈并输出 |  `#-*(`  | `/`  |    `ab+acd+e/`    |
|  18  |        |        |  isp(`(`)<icp(`-`)，直接出栈  | `#-*(-`  |      |    `ab+acd+e/`    |
|  19  |  `f`   | 操作数 |             输出              | `#-*(-`  | `f`  |   `ab+acd+e/f`    |
|  20  |  `)`   | 操作符 | isp(`*`)>icp(`)`)，出栈并输出 |  `#-*(`  | `-`  |   `ab+acd+e/f-`   |
|  21  |        |        | isp(`(`)==icp(`)`)，直接出栈  |  `#-*`   |      |   `ab+acd+e/f-`   |
|  22  |  `+`   | 操作符 | isp(`*`)>icp(`+`)，出栈并输出 |   `#-`   | `*`  |  `ab+acd+e/f-*`   |
|  23  |        |        | isp(`-`)>icp(`+`)，出栈并输出 |   `#`    | `-`  |  `ab+acd+e/f-*-`  |
|  24  |        |        |    isp(`#`)<icp(`+`),进栈     |   `#+`   |      |  `ab+acd+e/f-*-`  |
|  25  |  `g`   | 操作数 |             输出              |   `#+`   | `g`  | `ab+acd+e/f-*-g`  |
|  26  |  `#`   | 结束符 | isp(`+`)>icp(`#`)，出栈并输出 |   `#`    | `+`  | `ab+acd+e/f-*-g+` |
|  27  |        |        |   isp(`#`)==icp(`#`)，结束    |   `#`    |      | `ab+acd+e/f-*-g+` |

即相应的后缀表达式为 `ab+acd+e/f-*-g+`，栈内最多有 6 个操作符，但是 `#` 不算操作符，因此是五个，故选项 A 正确。
