# 栈在括号匹配中的应用

假设表达式中允许包含三种括号：圆括号`()`、方括号`[]`和花括号`{}`。
其嵌套的任意顺序即 `{[]()}` ， `{([][])}` ， `[{()}]` 都是合法的，但 `([)]` ， `{[}]` ， `{{}}}` 都是不合法的。

## 只包含 `()` `[]` 的情况

- 考虑以下括号序列：

```
[    (    [    ]    [    ]    )    ]
1    2    3    4    5    6    7    8
```

- 分析如下：
  - 计算机接收第一个括号 `[` ，期待与之匹配的第八个括号 `]` 出现。
  - 计算机接收第二个括号 `(` ，此时第一个括号 `[` 暂时放在一边，而迫切期待与之匹配的第七个括号 `)` 出现。
  - 获得了第三个括号 `[` ，此时第二个括号 `(` 暂时放在一边，而迫切期待与之匹配的第四个括号 `]` 出现。此时第三个括号得到满足，可以消失。在这个时候，第二个括号的期待匹配又成为了当前最急迫的任务。
  - 以此类推，直到最后一个括号 `]` 出现，整个括号序列得到满足。

由此可见，括号匹配的问题可以用栈来解决。

- 算法的思想如下：
  - 初始设置一个空栈，顺序读入括号。
  - 若是右括号，则或者使置于栈顶的最急迫期待得以消解，或者是出现不合法的情况（括号序列不匹配）
  - 若是左括号，则作为一个新的最急迫期待，压入栈中。自然使原有的在栈中的所有未消解的期待的急迫性都降低一级。
  - 算法结束时，栈为空，否则括号序列不匹配。

例题
[有效的括号](../../../../Algorithms/3.算法设计中的数据结构运用/单调栈/1.括号匹配.md)
