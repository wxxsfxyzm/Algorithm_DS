# 归并排序

## 基本思想

归并排序与上述基于交换、选择等排序的思想不一样，“归并”的含义是将两个或两个以上的有序表组合成一个新的有序表。假定待排序表中含有 n 个记录，则可将其视为 n 个有序的子表，每个子表的长度为 1，然后两两归并，得到 $\lceil\frac{n}{2}\rceil$ 个长度为 2 或 1 的有序子表；再两两归并，得到 n/4 个长度为 4 或 1 的有序子表...如此重复，直到得到一个长度为 n 的有序表为止。

下表所示为 2 路归并排序的一个例子，经过三趟归并后成为有序序列。

```
初始关键字 [49] [38] [65] [97] [76] [13] [27]

第一趟归并  [38 49]   [65 97]   [13 76]  [27]

第二趟归并    [38 49 65 97]      [13 27 76]

第三趟归并        [13 27 38 49 65 76 97]

```

## 算法设计

- `Merge()` 的功能是将前后相邻的两个有序表归并为一个有序表。设两段有序表 `A[low...mid]` 和 `A[mid+1...high]` 存放在同一个顺序表的相邻位置，先将他们复制到辅助数组 `B` 中。
- 每次归并的过程中，从对应 `B` 中的两个段取出一个记录进行关键字的比较，将较小的记录放入 `A` 中，当数组 `B` 中有一段的下标超出其对应的表长（即该段的所有元素都已复制到 `A` 中）时，将另一段中的剩余部分直接复制到 `A` 中。

算法如下：

```cpp
// use malloc in c:
// ElemType *B = (ElemType *)malloc(n * sizeof(ElemType));  // 辅助数组
ElemType *B = new ElemType[n];  // 辅助数组

void Merge(ElemType A[], int low, int mid, int high) {
    // 表A的两段A[low...mid]和A[mid+1...high]各自有序，将它们合并为一个有序表
    for(int k=low; k<=high; k++) B[k] = A[k];  // 复制到辅助数组B中
    for(int i=low, j=mid+1, k=i; i<=mid && j<=high; k++) {
        if(B[i] <= B[j]) A[k] = B[i++];
        else A[k] = B[j++];
    }
    // 两个while只有一个会执行
    while(i <= mid) A[k++] = B[i++];  // 若第一个表未检测完，复制
    while(j <= high) A[k++] = B[j++];  // 若第二个表未检测完，复制
}
```

- 一趟归并排序的操作是，调用 $\lceil\frac{n}{2h}\rceil$ 次算法 `Merge()`，将 `L[1...n]` 中前后相邻且长度为 h 的有序段进行两两归并，得到前后相邻，长度为 2h 的有序段。整个归并排序需要进行 $\lceil\log_2n\rceil$ 趟。
  - 分解：递归形式的 2 路归并排序的待排序表分成包含 n/2 个元素的子表，采用 2 路归并排序对两个子表递归地进行排序。
  - 合并：将两个有序子表合并为一个有序表。

```cpp
void MergeSort(ElemType A[], int low, int high) {
    if(low < high) {
        int mid = (low + high) / 2;
        MergeSort(A, low, mid);  // 递归地对前一半进行排序
        MergeSort(A, mid+1, high);  // 递归地对后一半进行排序
        Merge(A, low, mid, high);  // 合并
    }
}
```

## 性能分析

1. 空间效率： `Merge()` 函数中需要一个辅助数组 `B`，其长度与待排序表长度相同，故空间复杂度为 $O(n)$。
2. 时间效率：每一趟归并的时间复杂度为 $O(n)$ ，共需要进行 $\lceil log_2n\rceil$ 所以归并排序的时间复杂度为 $O(n\log_2n)$。
3. 稳定性：由于 `Merge()` 的操作不会改变相同关键字记录的相对次序，所以 2 路归并排序算法是稳定的排序方法。

**注意**：一般而言，对于 $N$ 个元素进行 $k$ 路归并排序时，排序的趟数 $m$ 满足 $k^m=N$ ，从而 $m=log_kN$，又考虑到 m 为整数，所以 $m=\lceil\log_kN\rceil$。这与二路归并排序的计算是一致的。
