# 快速排序

快速排序算法一般会被**重点**考察

## 基本思想

快速排序的基本思想是基于分治法的：在待排序表 `L[1...n]` 中任取一个元素 `pivot` 作为基准，通过一趟排序将待排序表划分为独立的两部分 `L[1...k-1]` 和 `L[k+1...n]`，使得 `L[1...k-1]` 中所有元素小于 `pivot`，`L[k+1...n]` 中所有元素大于 `pivot`，`pivot` 放在其最终位置 `L[k]` 上，这个过程称为一趟快速排序。

然后分别对 `L[1...k-1]` 和 `L[k+1...n]` 递归地进行快速排序，直到有序。

一趟快速排序的过程是一个交替搜索和交换的过程，下面通过一个例子来说明：

```
L = [50, 10, 90, 30, 70, 40, 80, 60, 20]
```

1. 取 `pivot = 50`，`low = 1`，`high = 9`，`key = 50`，`i = 1`，`j = 9`。

2. 从右向左搜索第一个小于 `key` 的元素，找到 `L[j] = 20`，交换 `L[i]` 和 `L[j]`，`L = [20, 10, 90, 30, 70, 40, 80, 60, 50]`。

3. 从左向右搜索第一个大于 `key` 的元素，找到 `L[i] = 90`，交换 `L[i]` 和 `L[j]`，`L = [20, 10, 50, 30, 70, 40, 80, 60, 90]`。

4. 重复步骤 2 和 3，直到 `i = j`，将 `key` 放在 `L[i]` 上，`L = [20, 10, 50, 30, 40, 70, 80, 60, 90]`。

5. 对 `L[1...4]` 和 `L[6...9]` 递归地进行快速排序。

## 算法实现

快速排序算法的关键在于划分操作，同时快速排序算法的性能也主要取决于划分操作的好坏。一般每次总以当前表中的第一个元素作为基准 `pivot`，通过一趟划分操作将表划分为满足上述条件的两个子表，表中比枢轴大的元素向右移动，将比枢轴小的元素向左移动，最后将枢轴放在其最终位置上。

一趟 `Partition()` 操作后，枢轴 `pivot` 将位于其最终位置 `pivotpos` 上，且其左边的元素均小于 `pivot`，右边的元素均大于 `pivot`，整个表中的元素被枢轴一分为二。

代码实现：

```cpp
int Partition(ElemType a[], int low, int high){
    ElemType pivot = a[low];                        // 将当前表中第一个元素设为枢轴值
    while (low < high){                             // 从表的两端交替地向中间扫描
        while (low < high && a[high] >= pivot)      // 从右向左扫描，找到第一个小于枢轴值的元素
            high--;
        a[low] = a[high];                           // 将比枢轴值小的元素移动到左端
        while (low < high && a[low] <= pivot)       // 从左向右扫描，找到第一个大于枢轴值的元素
            low++;
        a[high] = a[low];                           // 将比枢轴值大的元素移动到右端
    }
    a[low] = pivot;                                 // 枢轴元素存放到最终位置
    return low;                                     // 返回枢轴元素的位置
}
```

在一趟排序后，枢轴元素已经在其最终位置上，且左边的元素均小于枢轴，右边的元素均大于枢轴，接下来递归地对左右两个子表进行快速排序。

代码实现：

```cpp
void QuickSort(ElemType a[], int low, int high){
    if (low < high){                                // 递归跳出的条件
        // Partition() 就是划分操作，将表a划分为满足上述条件的两个子表
        int pivotpos = Partition(a, low, high);      // 一趟划分，返回枢轴的位置
        QuickSort(a, low, pivotpos - 1);             // 递归地对左子表进行快速排序
        QuickSort(a, pivotpos + 1, high);            // 递归地对右子表进行快速排序
    }
}
```

## 性能分析

1. 空间效率：快速排序是递归的，所以需要借助一个递归工作栈来保存每一层递归调用的返回地址、参数和局部变量等，其容量应该与递归调用的最大深度一致，最好情况下，递归调用的最大深度为 $\log_2n$，最坏情况下，递归调用的最大深度为 $n$，所以空间复杂度为 $O(\log_2n)$ 到 $O(n)$。平均情况下，栈的深度为 $O(\log_2n)$。

2. 时间效率：快速排序的时间效率主要取决于划分操作的好坏，最好情况下，每次划分都能将表均匀地划分为两个长度相等的子表，这样递归树的深度为 $\log_2n$，每层递归的时间复杂度为 $O(n)$，所以最好情况下的时间复杂度为 $O(n\log_2n)$；最坏情况下，每次划分都只能将表划分为一个长度为 $n-1$ 和一个长度为 0 的子表，递归树的深度为 $n$，每层递归的时间复杂度为 $O(n)$，所以最坏情况下的时间复杂度为 $O(n^2)$；平均情况下，每次划分都能将表均匀地划分为两个长度相等的子表，递归树的深度为 $\log_2n$，每层递归的时间复杂度为 $O(n)$，所以平均情况下的时间复杂度为 $O(n\log_2n)$。

3. 稳定性：快速排序是不稳定的排序算法，因为在划分操作中，相同元素的相对位置可能会发生变化。
   例如：$[5, 3, 5, 2, 8, 5, 7]$，第一次划分后，枢轴 5 将位于第 3 个位置，第二次划分后，枢轴 5 将位于第 5 个位置，所以第一个 5 和第三个 5 的相对位置发生了变化。

**注意**：在快速排序算法中，并不产生有序子序列，但每趟排序后会将枢轴（基准）元素放置于其最终位置上。
