# 选择排序

选择排序的基本思想是：每一趟（如第 i 趟）在后面 n-i+1(i=1,2,...,n-1)个元素中选取最小（或最大）的元素，与第 i 个元素交换位置。这样，经过 n-1 趟排序后，待排序列只剩下一个元素，就不用再排了，此时整个序列有序。

选择排序中的堆排序是历年考察的重点。

## 简单选择排序

### 基本思想

根据选择排序的思想，可以很直观的得出简单排序算法的思想：
假设排序表为 `L[1...n]`，第一趟排序从 `L[1...n]` 中选出最小的元素与 `L[1]` 交换，第二趟从 `L[2...n]` 中选出最小的元素与 `L[2]` 交换，依次类推，第 `i` 趟从 `L[i...n]` 中选出最小的元素与 `L[i]` 交换，直到第 `n-1` 趟排序结束。这样，经过 `n-1` 趟排序后，整个序列有序。

### 算法实现

```cpp
void SelectSort(ElemType a[], int n){
    for (int i = 0; i < n - 1; i++){
        int min = i;                                // 记录最小元素的位置
        for (int j = i + 1; j < n; j++){             // 在 L[i...n] 中选择最小的元素
            if (a[j] < a[min])
                min = j;
        }
        if (min != i)                               // 若最小元素不在 L[i]，则交换
            swap(a[i], a[min]);
    }
}
```

### 性能分析

1. 空间效率：简单选择排序是原地排序，空间复杂度为 $O(1)$。

2. 时间效率：简单选择排序的时间复杂度为 $O(n^2)$，无论初始序列如何，都需要进行 $n-1$ 趟排序，每趟排序的比较次数为 $n-i$，移动次数为 0 到 3 次，所以时间复杂度为 $O(n^2)$。

3. 稳定性：简单选择排序是不稳定的排序算法，当 `i<j` 且 `a[i]=a[j]` 时，可能会交换 `a[i]` 和 `a[j]` 的位置。
