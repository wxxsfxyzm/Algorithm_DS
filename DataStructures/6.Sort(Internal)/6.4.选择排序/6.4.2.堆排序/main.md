# 堆排序

## 定义

堆的定义如下：n 个关键字序列 `L[1..n]` 称为堆，当且仅当该序列满足：
&#x2460; $L[i] \leq L[2i]$ 且 $L[i] \leq L[2i+1]$ 或
&#x2461; $L[i] \geq L[2i]$ 且 $L[i] \geq L[2i+1]$ $(1 \leq i \leq \lfloor n/2 \rfloor)$。

可以将一个一维数组视为一棵完全二叉树，满足条件 &#x2460; 的堆成为大根堆（大顶堆），大根堆的最大元素存放在根结点，且其任意非根节点的值小于等于其双亲结点值。
满足条件 &#x2461; 的堆成为小根堆（小顶堆），小根堆的最小元素存放在根结点，且其任意非根节点的值大于等于其双亲结点值。

下面所示的就是一个大根堆：

| 87  | 45  | 78  | 32  | 17  | 65  | 53  | 09  |
| --- | --- | --- | --- | --- | --- | --- | --- |

```
            87
          /    \
        45      78
       /  \    /  \
     32   17  65  53
     /
    09
```

堆排序的基本思想是：将待排序的序列初始构造成一个大顶堆。此时，整个序列的最大值就是堆顶的根节点。输出堆顶元素（最大元素）后，将堆底元素送入堆顶，然后此时将剩余的 n-1 个序列重新构造成一个堆，这样就会得到 n 个元素中的次大值。如此反复执行，便能得到一个有序序列了。

堆排序需要解决两个问题：

1. 如何将一个无序序列构造成初始堆？
2. 如何在输出堆顶元素后，调整剩余元素成为一个新的堆？

### 初始堆的构造

堆排序的关键就是构造初始堆。n 个结点的完全二叉树，最后一个结点是第 $\lfloor n/2 \rfloor$ 个结点的孩子。对第 $\lfloor n/2 \rfloor$ 个结点为根的根的子树筛选（对于大根堆，若根关键字小于左右孩子中关键字较大者，则交换），使该子树成为堆。之后向前依次对各结点（ $\lfloor n/2 \rfloor -1$ ~ $1$ ）为根的子树进行筛选，看该结点的值是否大于其左右孩子的值，若不大于，则将左右子结点中的较大值与其交换，交换后可能会破坏下一级的堆，于是继续采用上述方法构造下一级的堆，直到以该结点为根的子树构成堆位置。反复进行，直到根结点为止，整个序列就是一个堆。

#### 构造初始堆算法实现

```cpp
void BuildMaxHeap(ElemType a[], int len){
    for(int i=len/2; i>0; i--){                 // 从最后一个非叶子结点开始反复调整堆
        HeadAdjust(a, i, len);
    }
}

void HeadAdjust(ElemType a[], int k, int len){
    // 函数HeadAdjust将元素k为根的子树进行调整
    a[0] = a[k];                                // a[0]暂存根结点
    for(int i=2*k; i<=len; i*=2){               // 沿key较大的孩子结点向下筛选
        if(i<len && a[i]<a[i+1])
            i++;                                // i为key较大的记录的下标
        if(a[0] >= a[i])
            break;                              // 筛选结束
        else{
            a[k] = a[i];                        // 将a[i]调整到双亲结点上
            k = i;                              // 修改k值，以便继续向下筛选
        }
    }
    a[k] = a[0];                                // 被筛选结点的值放入最终位置
}
```

性能分析：

调整的时间与树高有关，为 $O(h)$ 。在建立含 n 个元素的堆时，关键字的比较总次数不超过 4n，时间复杂度为 $O(n)$ ，这说明可以在线性时间内将一个无序数组建立成一个堆。

#### 堆排序算法实现：

```cpp
void HeapSort(ElemType a[], int len){
    BuildMaxHeap(a, len);                       // 初始堆
    for(int i=len; i>1; i--){
        swap(a[1], a[i]);                       // 将堆顶元素与堆底元素交换
        HeadAdjust(a, 1, i-1);                   // 调整，使其满足堆的性质
    }
}
```

同时，堆支持插入操作。在对堆进行插入操作时，先将新结点放在堆的末端，再对这个新结点向上执行调整操作。

#### 堆排序性能分析

堆排序适合关键字较多的情况，例如：在一亿个数中选出前 100 个最大的数，首先可以使用一个大小为 100 的数组，读入前 100 个数，建立小根堆，而后依次读入余下的数，若是小于堆顶则舍弃，否则用该数取代堆顶并调整堆，待数据读取完毕，堆中的 100 个数即为所求。

1. 空间效率：堆排序是原地排序，空间复杂度为 $O(1)$ 。

2. 时间效率：堆排序的时间复杂度为 $O(n\log_2n)$ ，堆排序的性能主要取决于初始堆的构造，建立堆的时间复杂度为 $O(n)$ ，调整堆的时间复杂度为 $O(\log_2n)$ ，所以堆排序的时间复杂度为 $O(n\log_2n)$ 。

3. 稳定性：堆排序是不稳定的排序算法，当 `i < j` 且 `a[i] = a[j]` 时，可能会交换 `a[i]` 和 `a[j]` 的位置。
   例如：表 $L=[1,(2),2]$ ，构造初始堆时可能将(2)交换到堆顶，此时 $L=[(2),1,2]$ ，最终排序序列为 $L=[1,2,(2)]$ 。显然两个 2 的相对位置发生了变化。
