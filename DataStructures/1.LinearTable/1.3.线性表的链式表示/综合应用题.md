# 链表综合应用题

1. 设计一个递归算法，删除不带头结点的单链表 L 中所有值为 x 的结点

   - 设 `f(L,x)` 的功能删除以 L 为首结点指针的单链表中所有值为 x 的结点，显然有 `f(L->next,x)` 的功能是删除以 L->next 为首结点指针的单链表中所有值为 x 的结点，由此可以推出递归模型如下

     - 终止条件：f(L,x) = NULL，若 L 为空表
     - 递归主体：f(L,x) = 删除\*L 结点; f(L->next,x)，若 L 结点的值为 x
       f(L,x)=f(L->next,x);

   - 代码如下：

   ```c++
    void Del_X(LinkList &L, ElemType x) {
        LNode *p;                       // p 指向待删除的头结点
        if (L == nullptr) return;       // 终止条件：表已经为空
        if (L->data == x) {             // 若 L 所指结点的值为 x
            p = L;
            L = L->next;                // 删除掉表头结点L
            delete(p);
            Del_X(L, x);                // 递归删除剩余结点
        } else {                        // 若 L 所指结点的值不为 x
            Del_X(L->next, x);          // 递归删除剩余结点
        }
    }
   ```

2. 在带头结点的单链表 L 中删除所有值为 x 的结点，并释放其空间，假设值为 x 的结点不唯一，试编写算法以实现上述操作。

   - 解法 1：用 p 从头到尾扫描单链表，pre 指向\*p 结点的前驱。若 p 所指结点的值为 x，则删除，并让 p 移向下一个结点，否则让 pre、p 指针同步后移一个结点。

     - 代码如下：

       ```c++
       void Del_X(LinkList &L, ElemType x) {
           LNode *p = L->next, *pre = L;   // p 指向首结点，pre 指向头结点
           while (p != nullptr) {          // 从头到尾扫描单链表
               if (p->data == x) {         // 若 p 所指结点的值为 x
                   pre->next = p->next;   // 删除 p 结点
                   delete(p);
                   p = pre->next;         // p 移向下一个结点
               } else {                    // 若 p 所指结点的值不为 x
                   pre = p;                // pre、p 指针同步后移一个结点
                   p = p->next;
               }
           }
       }
       ```

     - 本算法是在无序单链表中删除满足某种条件的所有结点，这里的条件是结点的值为 x。实际上，这个条件是可以任意指定的，只要修改 if 条件即可。比如，要求删除值介于 minK 和 maxK 之间的所有结点，则只需要将 if 的条件改为 `if(p->data > minK && p->data < maxK)` 即可。

   - 解法 2：采用尾插法建立单链表。用 p 指针扫描 L 的所有结点，当其值不为 x 时，将其链接到 L 之后，否则将其释放。

     - 代码如下：

     ```c++
     void Del_X(LinkList &L, ElemType x) {
         LNode *p = L->next, *r = L, *q;   // p 指向首结点，r 指向尾结点
         while (p != nullptr) {            // 从头到尾扫描单链表
             if (p->data != x) {           // 若 p 所指结点的值不为 x
                 r->next = p;              // 将 p 结点链接到 L 之后
                 r = p;                    // r 指向新的尾结点
             } else {                      // 若 p 所指结点的值为 x
                 q = p;                    // 释放 p 结点
                 p = p->next;
                 delete(q);
             }
         }
         r->next = nullptr;                // 尾结点的 next 域置空
     }
     ```

3. 设 L 为带头结点的单链表编写算法实现从尾到头反向输出每个结点的值。

   - 解法 1：递归算法。递归地输出 L->next 之后的结点，再输出 L 结点的值。

     - 代码如下：

     ```c++
     void Reverse_Print(LinkList L) {
         if (L->next != nullptr) {       // 递归终止条件
             Reverse_Print(L->next);     // 递归输出 L->next 之后的结点
         }
         if (L != nullptr) {             // 输出 L 结点的值
             cout << L->data << " ";
         }
     }
     void R_Ignore_Head(LinkList L) {
         if(L->next != nullptr)
           Reverse_Print(L->next);
     }
     ```

     **注意**：能用递归就能用栈，从反向想到栈，而栈又可以写成递归形式

   - 解法 2：栈的应用。将 L 的所有结点依次压入栈中，再依次弹出栈顶元素输出。

     - 代码如下：

     ```c++
     void Reverse_Print(LinkList L) {
         stack<LNode *> S;               // 定义一个栈
         LNode *p = L->next;             // p 指向首结点
         while (p != nullptr) {          // 将 L 的所有结点依次压入栈中
             S.push(p);
             p = p->next;
         }
         while (!S.empty()) {            // 依次弹出栈顶元素输出
             p = S.top();
             cout << p->data << " ";
             S.pop();
         }
     }
     ```

   - 更直观的解法：`vector`（其实就是用容器模拟栈）

     - 代码如下

     ```c++
        void Reverse_Print(LinkList L) {
            vector<LNode *> V;              // 定义一个 vector
            LNode *p = L->next;             // p 指向首结点
            while (p != nullptr) {          // 将 L 的所有结点依次压入 vector 中
                V.push_back(p);
                p = p->next;
            }
            for (int i = V.size() - 1; i >= 0; i--) {  // 逆序输出 vector 中的元素
                cout << V[i]->data << " ";
            }
        }
     ```

4. 试编写算法将带头结点的单链表 L 中删除一个最小值结点的高效算法（假设最小值结点是唯一的）

   - 算法思想：双指针法
     用 p 从头到尾扫描单链表，pre 指向\*p 结点的前驱。用 minp 保存值最小的结点指针（初值为 p），minpre 指向\*minp 结点的前驱（初值为 pre）。一边扫描，一边比较。若 p->data 小于 minp->data，则将 p、pre 分别赋值给 minp，minpre。当 p 扫描完毕时，minp 指向最小值结点，minpre 指向该结点的前驱结点，此时再删除\*minp 结点即可。

     - 代码如下

       ```c++
       void Del_Min_Node(LinkList &L){
        // L是带头结点的单链表，本算法通过双指针删除链表中最小元素的结点
        LNode *p = L->next, *pre = L, *minp = p, *minpre = pre; // p指向首结点，pre指向头结点
        while(p != nullptr){                                    // 从头到尾扫描单链表
            if(p->data < minp->data){                           // 若p所指结点的值小于minp所指结点的值
                minp = p;                                       // 更新minp
                minpre = pre;                                   // 更新minpre
            }
            pre = p;                                            // pre、p指针同步后移一个结点
            p = p->next;                                        // p指向下一个结点
        }                                                       // 循环结束，找到最小值结点
        minpre->next = minp->next;                              // 删除minp结点
        delete(minp);
       }
       ```

5. 试编写算法将带头结点的单链表就地逆置，所谓"就地"是指辅助空问复杂度为 O(1)。

   - 解法 1：
     算法思想：头插法
     用 p 指针扫描单链表，将 p 结点插入到头结点之后，直至 p 指向空为止。

     - 代码如下

       ```c++
       void Reverse(LinkList &L){
        // L是带头结点的单链表，本算法通过头插法逆置单链表
        LNode *p = L->next, *q; // p指向首结点
        L->next = nullptr;      // 置空原链表
        while(p != nullptr){    // 从头到尾扫描单链表
            q = p->next;        // q指向p的后继结点
            p->next = L->next;  // 将p结点插入到头结点之后
            L->next = p;
            p = q;              // p指向下一个结点
        }
       }
       ```

   - 解法 2：
     算法思想：三指针法
     用 p、q、r 三个指针，分别指向当前结点、前驱结点、后继结点。将 p 结点的 next 域指向 q 结点，然后依次向后移动 p、q、r 指针。

     - 代码如下

       ```c++
       void Reverse(LinkList &L){
           // L是带头结点的单链表，本算法通过三指针法逆置单链表
           // 依次遍历线性表L，并将结点指针反转
           LNode *p = L->next, *q = nullptr, *r = nullptr; // p指向首结点
           while(p != nullptr){                             // 从头到尾扫描单链表
               r = p->next;                                 // r指向p的后继结点
               p->next = q;                                 // 将p结点的next域指向q结点
               q = p;                                       // q、p指针同步后移一个结点
               p = r;
           }
           L->next = q;                                     // 头结点的next域指向原链表的尾结点
       }
       ```

6. 有一个带头结点的单链表 L，设计一个算法使其元素递增有序

   - 算法思想：直接插入排序
     从第一个结点开始先构成一个只含一个数据结点的有序表，然后依次扫描单链表中剩下的结点\*p，直至表尾`(*p==nullptr)`，在有序表中通过比较查找插入\*p 的前驱结点\*pre，然后将\*p 插入到\*pre 之后。

   - 代码如下

     ```cpp
       void Sort(LinkList &L){
            // L是带头结点的单链表，本算法通过直接插入排序使其元素递增有序
            LNode *p = L->next, *pre;   // p指向首结点
            LNode *r=p->next;           // r存储*p后继结点指针，以防断链
            p->next = nullptr;          // 断开原链表
            p = r;                      // p指向下一个结点
            while(p != nullptr){        // 从头到尾扫描单链表
                r = p->next;              // q指向p的后继结点
                pre = L;                  // pre指向头结点
                while(pre->next != nullptr && pre->next->data < p->data)
                // 在有序表中查找插入位置
                    pre = pre->next;       // pre指向p的前驱结点
                p->next = pre->next;      // 将p结点插入到pre结点之后
                pre->next = p;
                p = r;                    // p指向下一个结点
            }
       }
     ```

7. 设在一个带表头结点的单链表中所有元素结点的数据值无序，试编写一个函数，删除表 中所有介于给定的两个值（作为函数参数给出）之间的元素的元素（若存在）。
8. 给定两个单链表，编写算法找出两个链表的公共结点。
9. 给定一个带表头结点的单链表，设 head 为头指针，结点结构为(data，next)，data 为整型元素，next 为指针，试写出算法：按递增次序输出单链表中各结点的数据元素，并释放结点所占的存储空间（要求：不允许使用数组作为辅助空间）
10. 将一个带头结点的单链表 A 分解为两个带头结点的单链表 A 和 B，使得 A 表中含有原表中序号为奇数的元素，而 B 表中含有原表中序号为偶数的元素，且保持其相对顺序不变。
11. 设 C={$a_1,b_1,a_2,b_2,...,a_n,b_n$}为线性表，采用带头结点的 hc 单链表存放，设计一个就地算法，将其拆分为两个线性表，使得 A={$a_1,a_2,...,a_n$}，B={$b_1,b_2,...,b_n$}。
12. 在一个递增有序的线性表中，有数值相同的元索存在。若存储方式为单链表，设计算法去掉数值相同的元素，使表中不再有重复的元素，例如(71，10，10，21，30，42，42，42，51，70)将变为(7，10，21，30，42，51，70)。
13. 假设有两个按元素值递增次序排列的线性表，均以单链表形式存储。请编写算法将这两个单链表归并为一个按元素值递减次序排列的单链表，并要求利用原来两个单链表的结点存储归并后的单链表。
14. 设 A 和 B 是两个单链表（带头结点），其中元素递增有序。设计一个算法从 A 和 B 中公共元素产生单链表 C，要求不破坏 A、B 的结点。
15. 已知两个链表 A 和 B 分别表示两个集合，其元素递增有序。编写一个算法，求 A 和 B 的交集，并存放于 A 链表中。
16. 两个整数序列 A=$a_1,a_2,...,a_m$和 B=$b_1,b_2,...,b_n$已经存入两个单链表中，设计一个算法，判断序列 B 是否是序列 A 的连续子序列。
17. 设计一个算法用于判断带头结点的循环双链表是否对称。
18. 设有两个循环单链表，链表头指针分别为 h1 和 h2，编写一个算法将链表 h2 连接到链表 h1 之后，要求连接后的链表仍保持循环链表形式。
19. 设有一个带头结点的循环单链表，其结点值均为正整数。设计一个算法，反复找出单链表中结点值最小的结点并输出，然后将该结点从中删除，直到单链表空为止，再删除表头结点。
20. 设头指针为 L 的带有表头结点的非循环双向链表，其每个结点中除有 pred（前驱指针）、data（数据）和 next（后继指针）域外，还有一个访问频度域 freq。在链表被启用前，其值均初始化为零。每当在链表中进行一次 Locate(L,x)运算时，令元素值为 x 的结点中 freq 域的值增 1，并使此链表中的结点保持按访问频度非增（递减）的顺序排列，同时最近访问的结点排在频度相同的结点的前面，以便使频繁访问的结点总是靠近表头。试编写符合上述要求的 Locate(L,x)运算的算法，该算法为一个函数，返回找到结点的地址，类型为指针型。
21. 单链表有环，是指单链表的最后一个结点的指针指向链表中的某个结点（通常单链表的最后一个结点的指针域是空的）。试编写算法判断单链表是否存在环。
    - &#9312; 给出算法的基本设计思想
    - &#9313; 根据设计思想，采用 C、C++或 Java 语言描述算法，关键之处给出注释
    - &#9314; 分析算法的时间复杂度
22. 【2009 统考真题】已知一个带有表头结点的单链表，结点结构为

    | data | link |
    | ---- | ---- |

    假设该链表只给出了头指针 list。在不改变链表的前提下，设计一个尽可能高效的算法，查找链表中倒数第 k 个位置上的结点（k 为正整数）。若查找成功，算法输出该结点的 data 域的值，并返回 1；否则，只返回 0。要求：

    - &#9312; 给出算法的基本设计思想。
    - &#9313; 给出算法的详细实现步骤
    - &#9314; 根据设计思想，和实现步骤采用 C、C++或 Java 语言描述算法，关键之处给出注释。
    - &#9315; 说明你所设计算法的时间复杂度和空间复杂度。
