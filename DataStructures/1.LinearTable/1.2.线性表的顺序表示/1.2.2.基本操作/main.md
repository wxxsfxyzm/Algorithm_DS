# 线性表的基本操作

**注意**：仅讨论顺序表的插入、删除、按值查找操作。

## 1. 插入操作

在线性表 L 的第 i (`1 <= i <= L.length + 1`)个位置插入新元素 e。若 i 的输入不合法，则返回 false，表示插入失败；否则，将第 i 个元素及之后的元素后移，将元素 e 插入到位置 i，表长加 1，插入成功，返回 true。

```c++
bool ListInsert(SqList &L, int i, ElemType e) {
    if (i < 1 || i > L.length + 1) {            // 判断 i 的范围是否有效
        return false;
    }
    if (L.length >= MaxSize) {                  // 当前存储空间已满,不能插入
        return false;
    }
    for (int j = L.length; j >= i; j--) {       // 将第 i 个元素及之后的元素后移
        L.data[j] = L.data[j - 1];
    }
    L.data[i - 1] = e;                          // 在位置 i 插入元素 e
    L.length++;                                 // 表长加 1
    return true;
}
```

**注意 1**： 区别顺序表的位序和数组下标的关系，顺序表的位序是从 `1` 开始的，而数组的下标是从 `0` 开始的，因此，顺序表中的第 `i` 个元素在数组中的下标是 `i - 1`。

**注意 2**：为何判断插入位置是否合法时`if`语句用`length + 1`，而移动元素的`for`循环用`length`？
判断插入位置是否合法时使用 `length + 1` 是因为在顺序表（线性表的顺序存储结构）中，插入操作的有效位置是从 1 到 `length + 1`。这是因为你可以在表的末尾插入一个新元素，即在位置 `length + 1` 处。例如，如果一个表有 5 个元素，那么有效的插入位置是 1 到 6（包含 6），因为你可以在位置 6（即表的末尾）插入一个新元素。
而在移动元素的 `for` 循环中使用 `length` 是因为在插入新元素之前，需要将从插入位置开始的所有元素向后移动一位以腾出空间。这个过程从表的最后一个元素（即位置 `length` ）开始，直到达到插入位置 i。因此，循环从 `length` 开始递减，直到 `i`，确保每个从 `i` 位置开始的元素都被正确地向后移动一位。

### 时间复杂度分析

- 最好情况：在表尾( `i = n + 1` )插入，元素后移语句不执行，时间复杂度为 `O(1)`。
- 最坏情况：在表头( `i = 1` )插入，所有元素都后移，元素后移语句执行 n 次，时间复杂度为 `O(n)`。
- 平均情况：在表的中间位置插入，元素后移语句执行次数为 n/2，时间复杂度为 `O(n)`。
  $$ \sum\limits*{i=1}^{n+1}p_i(n-i+1)=\sum\limits*{i=1}^{n+1}\frac{1}{n+1}(n-i+1)=\frac{1}{n+1}\sum\limits\_{i=1}^{n+1}(n-i+1)=\frac{1}{n+1}\frac{n(n+1)}{2}=\frac{n}2 $$

## 2. 删除操作

删除线性表 L 的第 i (`1 <= i <= L.length`) 个位置的元素，并用引用变量 e 返回其值。若 i 的输入不合法，则返回 false，表示删除失败；否则，将第 i 个元素之后的元素前移，将元素 e 返回，表长减 1，删除成功，返回 true。

```c++
bool ListDelete(SqList &L, int i, ElemType &e) {
    if (i < 1 || i > L.length) {                // 判断 i 的范围是否有效
        return false;
    }
    e = L.data[i - 1];                          // 将要删除的元素赋值给 e
    for (int j = i; j < L.length; j++) {        // 将第 i 个元素之后的元素前移
        L.data[j - 1] = L.data[j];
    }
    L.length--;                                 // 表长减 1
    return true;
}
```

**注意**：删除操作的有效位置是从 1 到 `length`，因为你不能删除表中不存在的元素。例如，如果一个表有 5 个元素，那么有效的删除位置是 1 到 5（包含 5）。

### 时间复杂度分析

- 最好情况：在表尾( `i = n + 1` )删除，无需移动元素，时间复杂度为 `O(1)`。
- 最坏情况：在表头( `i = 1` )删除，需移动除第一个元素外的所有元素，时间复杂度为 `O(n)`。
- 平均情况：在表的中间位置删除，假设$ p*i $是删除第 i 个元素的概率，那么平均移动次数为
$$\sum\limits*{i=1}^{n}p*i(n-i)=\sum\limits*{i=1}^{n}\frac{1}{n}p*i(n-i)=\frac{1}{n}\sum\limits*{i=1}^{n}p_i(n-i)=\frac{1}n\frac{n(n-1)}2=\frac{n-1}2$$ ，时间复杂度为 `O(n)`。

## 3. 按值查找操作

在线性表 L 中查找与给定值 e 相等的元素，如果查找成功，返回该元素在表中的位置，否则返回 0。

```c++
int LocateElem(SqList L, ElemType e) {
    for (int i = 0; i < L.length; i++) {
        if (L.data[i] == e) {
            return i + 1;                       // 返回元素的位序
        }
    }
    return 0;                                   // 查找失败，返回 0
}
```

### 时间复杂度分析

- 最好情况：第一个元素就是要查找的元素，时间复杂度为 `O(1)`。
- 最坏情况：要查找的元素在表的最后一个位置，或者根本不存在，时间复杂度为 `O(n)`。
- 平均情况：假设$ p*i $是查找第 i 个元素的概率，那么平均查找次数为
$$\sum\limits*{i=1}^{n}p*i×i=\sum\limits*{i=1}^{n}\frac{1}{n}×i=\frac{1}{n}\frac{n(n+1)}{2}=\frac{n+1}2$$ ，时间复杂度为 `O(n)`。
