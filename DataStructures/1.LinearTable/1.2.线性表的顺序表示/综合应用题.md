# 综合应用

1. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息，并退出运行。

   - 算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置。

   ```cpp
   bool Del_Min(sqList &L, ElemType &value){
       // 删除顺序表L中最小值元素的结点，并通过引用型参数value返回其值
       // 若删除成功，返回true；否则返回false
       if(L.length == 0){                      // 顺序表为空
           return false;                       // 终止操作并返回
       }
       value = L.data[0];                      // value 记录最小值，假设第一个元素最小
       int pos = 0;                            // pos 记录最小元素位置
       for(int i = 1; i < L.length; i++){      // 遍历所有元素查找最小元素
           if(L.data[i] < value){              // 找到更小的元素
               value = L.data[i];              // 更新value记录的最小值
               pos = i;                        // 更新pos记录的最小值位置
           }
       }
       L.data[pos] = L.data[L.length - 1];     // 用最后一个元素填补空出的最小值元素
       L.length--;                             // 顺序表长度减1
       return true;                            // 删除成功
   }
   ```

2. 设计一个高效算法，将顺序表 L 的所有元素逆置，要求算法的空间复杂度为 O(1)。

   - 算法思想：将顺序表的第一个元素与最后一个元素交换，第二个元素与倒数第二个元素交换，以此类推，直到中间元素。

   ```cpp
   void Reverse(sqList &L){
       // 逆置顺序表L中的所有元素
       ElemType temp;                          // 交换元素的临时变量
       for(int i = 0; i < L.length / 2; i++){  // 交换前一半元素
           temp = L.data[i];                   // 交换元素
           L.data[i] = L.data[L.length - 1 - i];
           L.data[L.length - i - 1] = temp;
       }
   }
   ```

3. 对长度为 n 的顺序表 L，编写一个时间复杂度为 O(n)、空间复杂度为 O(1)的算法，该算法删除线性表中所有值为 x 的数据元素。

   - 解法 1：用 k 记录顺序表中不等于 x 的元素个数，遍历顺序表，将不等于 x 的元素向前移动 k 个位置。

   ```cpp
   void Del_x_1(sqList &L, ElemType x){
       // 删除顺序表L中所有值为x的元素
       int k = 0;                              // k记录不等于x的元素个数
       for(int i = 0; i < L.length; i++){      // 遍历顺序表
           if(L.data[i] != x){                 // 找到不等于x的元素
               L.data[k] = L.data[i];          // 将不等于x的元素向前移动k个位置
               k++;                            // k自增
           }
       }
       L.length = k;                           // 顺序表长度为k
       // 也可以用while循环
       // int i = 0;
       // while(i < L.length){
       //     if(L.data[i] == x){
       //         k++;
       //     }else{
       //         L.data[i-k] = L.data[i];     // 将不等于x的元素向前移动k个位置
       //         i++;
       //     }
       // L.length -= k;                        // 顺序表长度为k
   }
   ```

   - 解法 2：用 k 记录顺序表 L 中不等于 x 的元素个数（即需要保存的元素个数），遍历顺序表，将不等于 x 的元素移动到下标为 k 的位置，并更新 k 的值。扫描结束后修改 L 的长度。

   ```cpp
   void Del_x_2(sqList &L, ElemType x){
       // 删除顺序表L中所有值为x的元素
       int k = 0;                              // k记录不等于x的元素个数
       for(int i = 0; i < L.length; i++){      // 遍历顺序表
           if(L.data[i] != x){                 // 找到不等于x的元素
               L.data[k] = L.data[i];          // 将不等于x的元素移动到下标为k的位置
               k++;                            // k自增
           }
       }
       L.length = k;                           // 顺序表长度为k
   }
   ```

   - 此外，本题还可以考虑设头尾指针，从两端向中间移动，在遇到最左端值为 x 的元素时，直接将最右端的值非 x 的元素左移至值为 x 的元素位置，直到两指针相遇。但这种方法会改变原表中元素的相对位置。

4. 从有序顺序表中删除其值在给定值 s 与 t 之间（要求 `s<t`）的所有元素，如果 s 或 t 不合理或顺序表为空，则显示出错信息并退出运行。

   - 本题与上一题存在区别，上一题是删除所有值为 x 的元素，而本题是删除值在 s 与 t 之间的所有元素。
   - 先寻找大于等于 s 的第一个元素（第一个要删除的元素）。然后寻找值大于 t 的第一个元素（最后一个删除的元素的下一个元素），要将这段元素删除，只需将后面的元素向前移动。

   ```cpp
   bool Del_s_t2_1(SqList &L,ElemType t){
       // 删除有序顺序表L中所有值在s与t之间的元素
       if(L.length == 0 || s >= t){            // 顺序表为空或s>=t
           return false;                       // 终止操作并返回
       }
       int i = 0;                              // i记录值在s与t之间的元素个数
       while(i < L.length && L.data[i] < s){   // 寻找大于等于s的第一个元素
           i++;
       }
       if(i >= L.length){                      // 顺序表中不存在值在s与t之间的元素
           return false;                       // 终止操作并返回
       }
       int j = i;                              // j记录值大于t的第一个元素
       while(j < L.length && L.data[j] <= t){  // 寻找值大于t的第一个元素
           j++;
       }
       while(j < L.length){                    // 将值大于t的元素向前移动
           L.data[i] = L.data[j];              // 后面的元素向前移动
           i++;
           j++;
       }
       L.length = i;                           // 顺序表长度为i
       return true;                            // 删除成功
   }
   ```

   或者

   ```cpp
   bool Del_s_t2_2(SqList &L,ElemType t){
       int i,k = 0;                            // k记录值在s与t之间的元素个数
       if(L.length == 0 || s >= t){            // 顺序表为空或s>=t
           return false;                       // 终止操作并返回
       }
       for(i = 0; i < L.length && L.data[i] < s; i++); // 寻找大于等于s的第一个元素
           if(L.data[i] >= s && L.data[i] <= t)// 顺序表中不存在值在s与t之间的元素
               k++;                            // k自增
           else
               L.data[i-k] = L.data[i];        // 将值在s与t之间的元素向前移动
       L.length -= k;                          // 顺序表长度减k
       return true;                            // 删除成功
   }
   ```

5. 从顺序表中删除其值在给定值 s 与 t 之间（包含 s 和 t，要求 `s<t`）的所有元素，如果 s 或 t 不合理或顺序表为空，则显示出错信息并退出运行。

   - 算法思想：从前到后遍历顺序表，用 k 记录元素值在 s 与 t 之间的元素个数，初始时 k 为 0，对于当前扫描的元素，若其值不在 s 与 t 之间，则将其前移 k 个位置；否则，执行 k++。
   - 由于这样每个不在 s 到 t 之间的元素仅移动一次，因此算法效率高。

   ```cpp
   bool Del_s_t3(SqList &L,ElemType s,ElemType t){
       // 删除有序顺序表L中所有值在s与t之间的元素
       if(L.length == 0 || s >= t){            // 顺序表为空或s>=t
           return false;                       // 终止操作并返回
       }
       int i,k = 0;                            // k记录值在s与t之间的元素个数
       for(i = 0; i < L.length; i++){          // 遍历顺序表
           if(L.data[i] >= s && L.data[i] <= t)// 找到值在s与t之间的元素
               k++;                            // k自增
           else
               L.data[i-k] = L.data[i];        // 将值在s与t之间的元素向前移动
       }
       L.length -= k;                          // 顺序表长度减k
       return true;                            // 删除成功
   }
   ```

6. 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。

   - 算法思想：类似直接插入排序，从前到后遍历顺序表，初始时将第一个元素视为无重复元素，之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同则继续向后判断，若不同，则插入前面的非重复有序表的最后一个元素之后，直到判断到表尾为止。

   ```cpp
   void Del_same(SqList &L){
       // 删除有序顺序表L中所有重复的元素
       if(L.length == 0){                      // 顺序表为空
           return false;                       // 终止操作并返回
       }
       int i,j;                                // i,j记录遍历顺序表的下标
       for(i = 0,j = 1; j < L.length; j++){    // 遍历顺序表
           if(L.data[i] != L.data[j]){         // 找到不重复的元素
               L.data[++i] = L.data[j];        // 将不重复的元素插入到前面
           }
       }
   }
   ```

   - 如果将有序表改为无序表，使用散列表可以在 `O(n)` 时间内完成

7. 将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。

   - 算法思想：首先按顺序不断取下两个顺序表表头较小的结点存入新顺序表中，然后，看哪个表还有剩余，将剩余的部分直接复制到新顺序表的尾部。

   ```cpp
    void Merge(SqList A,SqList B,SqList &C){
         // 将有序顺序表A和B合并为新的有序顺序表C
         if(A.length + B.length > C.MaxSize){  // 新顺序表长度不够
             return false;                      // 终止操作并返回
         }
         int i = 0,j = 0,k = 0;                 // i,j,k分别记录A、B、C的下标
        while(i<A.length&&j<B.length){
            if(A.data[i]<=B.data[j])
                C.data[k++]=A.data[i++];
            else
                C.data[k++]=B.data[j++];
        }
        while(i<A.length)
            C.data[k++]=A.data[i++];
        while(j<B.length)
            C.data[k++]=B.data[j++];
        C.length=k;
        return true;
    }
   ```

8. 已知在一维数组 A[m+n] 中依次存放两个线性表 $[a_1,a_2,a_3,...,a_m]$ 和 $[b_1,b_2,b_3,...,b_n]$。编写一个函数，将数组中两个顺序表的位置互换，即将数组中 $[b_1,b_2,b_3,...,b_n]$ 放在 $[a_1,a_2,a_3,...,a_m]$ 前面。

   - 算法思想：先将整个数组原地逆置，再对前 n 个元素和后 m 个元素分别逆置。

   ```cpp
      void Reverse(int A[],int left,int right,int arraySize){
       // 将数组中下标left到right的元素逆置
       if(left>=right||right>=arraySize)   // 判断下标是否合法
           return;
       int mid = (left+right)/2;
       for(int i=0;i<=mid-left;i++)
           swap(A[left+i],A[right-i]);
   }
   void Exchange(int A[],int m,int n,int arraySize){
       // 将数组A中前m个元素和后n个元素互换
       Reverse(A,0,m+n-1,arraySize);       // 将整个数组逆置
       Reverse(A,0,n-1,arraySize);         // 将前n个元素逆置
       Reverse(A,n,m+n-1,arraySize);       // 将后m个元素逆置
   }
   ```

9. 线性表 $(a_1,a_2,a_3,...,a_m)$ 中的元素递增有序且按顺序存储在计算机中。要求设计一个算法，完成用最少的时间在表中查找数值为 `x` 的元素，若找到，则将其与后继元素位置相交换，若找不到则将其插入表中并使表中元素仍递增有序。

   - 算法思想：题目给出的线性表已经**递增有序**，又要求**在最少的时间内查找**元素，因此想到使用[折半查找](../../5.Search/5.2.顺序查找和折半查找/main.md#折半查找)来提高效率

   ```cpp
    void SearchExchangeInsert(int A[],int n,int x){
       // 在有序表A中查找x，找到则与后继元素交换，找不到则插入
       int low = 0, high = n - 1, mid;      // low和high指向顺序表的上界和下界的下标
       while(low <= high){
           mid=(low + high) / 2;        // 找中间位置
           if(A[mid] == x)              // 如果 x 正好在中间
               break;                   // 就退出循环
           else if(A[mid] < x)          // 如果 x 在右侧
               low = mid + 1;           // low 调整为右侧第一个
           else                         // 如果 x 在左侧
               high = mid - 1;          // high 调整为左侧最后一个
       }
       // 找到 x 以后
       // 以下两个 if 只会执行一个
       if(A[mid] == x && mid != n - 1) // 若最后一个元素是x，则没有元素可以交换
            swap(A[mid],A[mid + 1]);
       if(low > high){                      // 查找失败，插入数据元素
            for(int i = n - 1;i > high;i--);// 从后往前将元素依次后移
                A[i+1] = A[i];
                A[i+1] = x;                 // 插入 x
       }
    }
   ```

10. 【2010 统考真题】设将 $n (n>1)$个整数存放到一维数组 R 中，设计一个在时间和空间两方面都尽可能高效的算法，将 R 中保存的序列循环左移 p $(0 < p < n)$ 个位置，即将 R 中的数据由 $(X_0,X_1,...,X_{n-1})$ 变换为$(X_p,X_{p+1},...,X_{n-1},X_0,X_1,...,X_{p-1})$。

    1. 给出算法的基本设计思想。
    2. 根据设计思想，写出代码，关键之处给出解释
    3. 说明你所设计的算法的时间复杂度以及时间复杂度

    - 算法思想：可将这个问题视为把数组 ab 转换成数组 ba 的问题（a 代表数组前 p 个元素，b 代表数组中余下的 n-p 个元素），先将 a 逆置得到 $a^{-1}b$，再将 b 逆置得到 $a^{-1}b^{-1}$，最后将整个数组逆置得到 $(a^{-1}b^{-1})^{-1}=ba$。
    - 设 `Reverse` 函数执行将数组元素逆置的操作，对 abcdefgh 向左循环移动三位(p=3)的过程如下：

      - `Reverse(0,p-1)`：得到 cba|defgh
      - `Reverse(p,n-1)`：得到 cba|hgfed
      - `Reverse(0,n-1)`：得到 defgh|abc
        注：`Reverse` 函数中，两个参数分别表示数组中待转换元素的始末位置

    - 使用 c++ 实现如下：

    ```cpp
    void Reverse(int R[],int from,int to){//原地逆置
        int i, temp;
        for(i=0;i<(to-from+1)/2;i++){
            swap(R[from+i],R[to-i]);
        }
    }
    void Converse(int R[],int n,int p){//整体逆置
        Reverse(R,0,p-1);
        Reverse(R,p,n-1);
        Reverse(R,0,n-1);
    }
    ```

    - 上述算法中三个 `Reverse` 函数的时间复杂度分别为 $O(p/2)$、$O((n-p)/2)$ 和 $O(n/2)$，因此整体时间复杂度为 $O(n)$，因为逆置使用的是原地逆置，没有占用新的存储空间，所以空间复杂度为 $O(1)$

11. 【2011 统考真题】一个长度为 L $(L \geq 1)$ 的升序序列 S，处在第 $\frac{L}{2}$ 个位置的数称为 S 的中位数。例如，若序列 $S_1=(11,13,15,17,19)$，则 $S_1$ 的中位数是 15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若 $S_2=(2,4,6,8,20)$，则 $S_1$ 和 $S_2$ 的中位数是 11。现在有两个等长升序序列 $A$ 和 $B$，设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列 $A$ 和 $B$ 的中位数。

    - 算法思想：分别求两个升序序列的中位数，比较两个中位数的大小，若相等则返回，若不等则舍弃较小的中位数及其左边的元素和较大的中位数及其右边的元素，递归调用该算法，直到两个序列的长度为 1 时，返回两个序列中较小的元素。
      具体如下：

      - &#9312; 若 $a=b$，则中位数为 a 或 b，算法结束。
      - &#9313; 若 $a < b$，则舍弃序列 A 中较小的一半和序列 B 中较大的一半，要求两次舍弃的长度相等。
      - &#9314; 若 $a > b$，则舍弃序列 A 中较大的一半和序列 B 中较小的一半，要求两次舍弃的长度相等。
        在保留的两个升序序列中，重复过程 &#9312;、&#9313;、&#9314;，直到两个序列的长度为 1 时，较小者即为所求的中位数。

    - 使用 c++ 实现如下：

    ```cpp
    int M_Search(int A[],int B[],int n){
        // 分别表示序列A和B的首位数、末位数和中位数
        int s1=0,d1=n-1,m1,s2=0,d2=n-1,m2;
        while(s1!=d1||s2!=d2){
            m1=(s1+d1)/2;
            m2=(s2+d2)/2;
            if(A[m1]==B[m2])                // 满足条件1
                return A[m1];               // 直接返回
            if(A[m1]<B[m2]){                // 满足条件2
                if((s1+d1)%2==0){           // 若元素个数为奇数
                    s1=m1;                  // 舍弃A中间点以前的部分且保留中间点
                    d2=m2                   // 舍弃B中间点以后的部分且保留中间点
                }
                else{                       // 元素个数为偶数
                    s1=m+1;                 // 舍弃A中间点以及中间点以前部分
                    d2=m2;                  // 舍弃B中间点以及中间点以后部分
                }
            }
            else{                           // 满足条件3
                if((s2+d2)%2==0){           // 若元素个数为奇数
                    d1=m1;                  // 舍弃A中间点以前的部分且保留中间点
                    s2=m2;                  // 舍弃B中间点以后的部分且保留中间点
                }
                else{                       // 元素个数为偶数
                    d1=m1;                  // 舍弃A中间点以及中间点以后部分
                    s2=m2+1;                // 舍弃B中间点以及中间点以前部分
                }
            }
        }
        return A[s1]<B[s2]?A[s1]:B[s2];    // 返回两个序列中较小的元素
    }
    ```

    - 实现程序的时间复杂度为 $O(\log_2n)$，空间复杂度为 $O(1)$

12. 【2013 统考真题】一直一个整数序列 $A=(a_0,a_1,...,a_{n-1})$，其中 $0 \leq a_i \leq n$。若存在 $a_{p1}=a_{p2}=\cdots=a_{pm}=x$ 且 $m>\frac{n}{2} (0 \leq p_k<n,1\leq k\leq m)$，则称 x 为 A 的主元素。例如，$A=(0,5,5,3,5,7,5,5)$ 中的 5 为主'元素；$A=(0,5,5,3,5,1,5,7)$ 中，A 没有主元素。假设 A 中的 n 个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出 A 的主元素。若存在主元素，则输出该元素；否则输出 -1。要求

    1. 给出算法的基本设计思想。
    2. 根据设计思想，写出代码，关键之处给出解释
    3. 说明你所设计的算法的时间复杂度以及时间复杂度

    - 算法思想：算法的策略是从前往后扫描数组元素，标记处一个可能成为主元素的元素 Num。然后重新计数，确认 Num 是否为主元素。
    - 算法可以分为两步

      - &#9312;选取候选的主元素。依次扫描所给数组的每个整数，将第一个遇到的整数 Num 保存到 c 中，记录次数为 1，然后继续扫描，若下一个整数与 c 相同，则次数加 1，否则次数减 1，若次数为 0，则将下一个整数保存到 c 中，次数重新置为 1，继续扫描。最后得到的整数 c 即为候选的主元素。
      - &#9313;判断 c 中元素是否是真正的主元素。再次扫描该数组，统计 c 中元素出现的次数，若大于 n/2，则 c 为主元素，否则输出 -1。

    - 使用 c++ 实现如下：

    ```cpp
    int Majority(int A[],int n){
        int i,c,count=1;                // c记录候选主元素，count记录候选主元素出现的次数
        c=A[0];                         // 第一个元素作为候选主元素
        for(i=1;i<n;i++){               // 从第二个元素开始扫描
            if(A[i]==c)
                count++;                // 若下一个元素与c相同，次数加1
            else
                if(count>0)
                    count--;            // 若下一个元素与c不同，次数减1
                else{
                    c=A[i];             // 若次数为0，将下一个元素保存到c中
                    count=1;            // 次数重新置为1
                }
            if(count>0)                 // 若次数大于0，c为候选主元素
                for(i=count=0;i<n;i++)  // 统计候选主元素出现的次数
                    if(A[i]==c)
                        count++;
            if(count>n/2)               // 验证c是否为主元素
                return c;               // 满足条件，输出主元素
            else
                return -1;              // 不存在主元素
    }
    ```

    - 实现程序的时间复杂度为 $O(n)$，空间复杂度为 $O(1)$
      说明：本题如果采用先排好序在统计的方法【时间复杂度可为 $O(n\log_2n)$】，只要解答正确，也可以得到部分分数（最高 11 分）。即使是写出 $O(n^2)$，最高也能拿 10 分，因此对于统考算法题，花费大量时间在时间复杂度上不是很有必要。

13. 【2018 统考真题】给定一个含 $n(n \geq 1)$ 个整数的数组，请设计一个在时间和空间两方面都尽可能高效的算法，找出数组中未出现的最小正整数。例如，数组 {-5,3,2,3} 中未出现的最小正整数是 1；数组 {1,2,3} 中未出现的最小正整数是 4。要求

    1. 给出算法的基本设计思想
    2. 根据设计思想，写出算法的详细实现，关键之处给出注释
    3. 说明你所设计的算法的时间复杂度和空间复杂度

    - 算法思想：要求在时间上尽可能高效，因此采用空间换时间的方法。分配一个用于标记的数组 B[n]，用来记录 A 中是否出现了 1~n 中的正整数，B[0]对应正整数 1，B[n-1]对应正整数 n，初始化 B 中全部为 0。由于 A 中含有 n 个整数，因此可能返回的值是 1~n+1，当 A 中 n 个数恰好为 1~n 时返回 n+1，当数组 A 中出现了小于等于 0 或者大于 n 的值时，会导致 1~n 中出现空余位置，返回结果必然在 1~n 中，因此对于 A 中出现了小于等于 0 或大于 n 的值，可以不采取任何操作。
    - 经过以上分析可以得出算法流程：从 A[0]开始遍历 A，若 $0<A[i]<=n$，则令 B[A[i]-1]=1，否则不做操作。对 A 遍历结束后，开始遍历数组 B，若能查找到第一个满足 B[i]==0 的下标 i，则返回 i+1，此时说明 A 中未出现的最小正整数在 1~n 之间。若 B[i]全部不为 0，则返回 i+1，此时说明 A 中未出现的最小正整数为 n+1。

    - 使用 c++ 实现如下：

    ```cpp
    int findMissMin(int A[],int n){
        int i;
        int *B = new int[n]();          // 动态分配数组B并初始化为int的默认值0
        for(i=0;i<n;i++)                // 遍历A
            if(A[i]>0&&A[i]<=n)         // 若A[i]在1~n之间
                B[A[i]-1]=1;            // 标记B[A[i]-1]为1
        for(i=0;i<n;i++)                // 遍历B
            if(B[i]==0)                 // 查找第一个B[i]==0的下标
                return i+1;             // 返回i+1
        return n+1;                     // 返回n+1
    }
    ```

    - 时间复杂度：遍历 A 一次，遍历 B 一次，两次循环内操作步骤为 $O(1)$，因此总时间复杂度为 $O(n)$
    - 空间复杂度：因为额外分配了数组 B，所以空间复杂度为 $O(n)$

14. 【2020 统考真题】定义三元组(a,b,c)(a、b、c 均为正数)的距离 D 为 D=|a-b|+|b-c|+|c-a|。给定三个升序序列 A、B 和 C，设计一个尽可能高效的算法，找出一个三元组，使得它们的距离 D 最小。要求

    1. 给出算法的基本设计思想
    2. 根据设计思想，写出算法的详细实现，关键之处给出注释
    3. 说明你所设计的算法的时间复杂度和空间复杂度

    - 分析：由 $D=|a-b|+|b-c|+|c-a| \geq 0$ 能够得出以下结论：
      - &#9312; 若 a=b=c，则 D=0，此时 D 最小
      - &#9313; 其他情况。不失一般性，假设 $a \leq b \leq c$，则 $D=(c-a)+(c-a)=2c-2a$，因此 $c-a$ 最小时 D 最小，即 c 最小，a 最大。因此，可以将问题转化为在三个升序序列中找出一个三元组，使得它们的距离 D 最小。
    - 由 D 的表达式可知，事实上决定 D 的大小的关键是 a 和 c 之间的距离，于是问题就可以简化为每次固定 c 找一个 a，使得 L=|c-a|最小。

    - 算法的基本思想：

      - &#9312; 使用 $D_{min}$ 记录已经处理的三元组的最小距离，初值为一个足够大的整数
      - &#9313; 集合 $S_1$、$S_2$、$S_3$ 分别保存在数组 A、B、C 中。数组的下标变量 `i=j=k=0` 分别指向三个数组的第一个元素。当 $i<|S_1|$、$j<|S_2|$ 且 $k<|S_3|$ 时（$|S|$ 表示集合 $S$ 中的元素个数），循环执行下面的 `a)` 到 `c)`。
        - `a)` 计算(A[i],B[j],C[k])的距离 D；（计算 D）。
        - `b)` 若 D<$D_{min}$，则更新 $D_{min}$ 为 D，记录当前的三元组；（更新 D）
        - `c)` 将 A[i]、B[j]、C[k]中最小的元素所在的数组的下标加 1
          对照分析：最小值为 a，最大值为 c，这里 c 不变而更新 a，试图寻找更小的距离 D
      - &#9314; 返回 $D_{min}$，即为所求的最小距离 D 对应的三元组

    - 算法实现

    ```cpp
    #include <cmath>    // abs函数
    #include <climits>  // INT_MAX
    bool xls_min(int a,int b,int c){    // 判断a是否为三个数中的最小值
        return a<=b&&a<=c;
    }
    int findMinOfTrip(int A[],int n,int B[],int m,int C[],int p){
        // D_min用于记录三元组的最小距离，赋初始值为INT_MAX
        int i=0,j=0,k=0,D_min=INT_MAX,D;
        while(i<n&&j<m&&k<p&&D_min>0){
            D=abs(A[i]-B[j])+abs(B[j]-C[k])+abs(C[k]-A[i]); // 计算当前的D值
            if(D<D_min)                 // 若当前的D比记录的D_min还要小
                D_min = D;              // 则更新D_min的值为当前的D值
            if(xls_min(A[i],B[j],C[k])) // 若A为三个值中的最小值
                i++;                    // A下标+1
            else if(B[j],A[i],C[k])     // 若B为三个值中的最小值
                j++;                    // B下标+1
            else                        // 若C为三个值中的最小值
                k++;                    // C下标+1
        }
        return D_min;                   // 返回最小值
    }
    ```

    - 设 $n=(|S_1|+|S_2|+|S_3|)$，则时间复杂度为 $O(n)$，空间复杂度为 $O(1)$。
