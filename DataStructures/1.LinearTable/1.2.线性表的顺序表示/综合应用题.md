# 综合应用

1. 从顺序表中删除具有最小值的元素（假设唯一）并由函数返回被删元素的值。空出的位置由最后一个元素填补，若顺序表为空则显示出错信息，并退出运行。

   - 算法思想：搜索整个顺序表，查找最小值元素并记住其位置，搜索结束后用最后一个元素填补空出的原最小值元素的位置。

   ```cpp
   bool Del_Min(sqList &L, ElemType &value){
       // 删除顺序表L中最小值元素的结点，并通过引用型参数value返回其值
       // 若删除成功，返回true；否则返回false
       if(L.length == 0){                      // 顺序表为空
           return false;                       // 终止操作并返回
       }
       value = L.data[0];                      // value 记录最小值，假设第一个元素最小
       int pos = 0;                            // pos 记录最小元素位置
       for(int i = 1; i < L.length; i++){      // 遍历所有元素查找最小元素
           if(L.data[i] < value){              // 找到更小的元素
               value = L.data[i];              // 更新value记录的最小值
               pos = i;                        // 更新pos记录的最小值位置
           }
       }
       L.data[pos] = L.data[L.length - 1];     // 用最后一个元素填补空出的最小值元素
       L.length--;                             // 顺序表长度减1
       return true;                            // 删除成功
   }
   ```

2. 设计一个高效算法，将顺序表 L 的所有元素逆置，要求算法的空间复杂度为 O(1)。

   - 算法思想：将顺序表的第一个元素与最后一个元素交换，第二个元素与倒数第二个元素交换，以此类推，直到中间元素。

   ```cpp
   void Reverse(sqList &L){
       // 逆置顺序表L中的所有元素
       ElemType temp;                          // 交换元素的临时变量
       for(int i = 0; i < L.length / 2; i++){  // 交换前一半元素
           temp = L.data[i];                   // 交换元素
           L.data[i] = L.data[L.length - 1 - i];
           L.data[L.length - i - 1] = temp;
       }
   }
   ```

3. 对长度为 n 的顺序表 L，编写一个时间复杂度为 O(n)、空间复杂度为 O(1)的算法，该算法删除线性表中所有值为 x 的数据元素。

   - 解法 1：用 k 记录顺序表中不等于 x 的元素个数，遍历顺序表，将不等于 x 的元素向前移动 k 个位置。

   ```cpp
   void Del_x_1(sqList &L, ElemType x){
       // 删除顺序表L中所有值为x的元素
       int k = 0;                              // k记录不等于x的元素个数
       for(int i = 0; i < L.length; i++){      // 遍历顺序表
           if(L.data[i] != x){                 // 找到不等于x的元素
               L.data[k] = L.data[i];          // 将不等于x的元素向前移动k个位置
               k++;                            // k自增
           }
       }
       L.length = k;                           // 顺序表长度为k
       // 也可以用while循环
       // int i = 0;
       // while(i < L.length){
       //     if(L.data[i] == x){
       //         k++;
       //     }else{
       //         L.data[i-k] = L.data[i];     // 将不等于x的元素向前移动k个位置
       //         i++;
       //     }
       // L.length -= k;                        // 顺序表长度为k
   }
   ```

   - 解法 2：用 k 记录顺序表 L 中不等于 x 的元素个数（即需要保存的元素个数），遍历顺序表，将不等于 x 的元素移动到下标为 k 的位置，并更新 k 的值。扫描结束后修改 L 的长度。

   ```cpp
   void Del_x_2(sqList &L, ElemType x){
       // 删除顺序表L中所有值为x的元素
       int k = 0;                              // k记录不等于x的元素个数
       for(int i = 0; i < L.length; i++){      // 遍历顺序表
           if(L.data[i] != x){                 // 找到不等于x的元素
               L.data[k] = L.data[i];          // 将不等于x的元素移动到下标为k的位置
               k++;                            // k自增
           }
       }
       L.length = k;                           // 顺序表长度为k
   }
   ```

   - 此外，本题还可以考虑设头尾指针，从两端向中间移动，在遇到最左端值为 x 的元素时，直接将最右端的值非 x 的元素左移至值为 x 的元素位置，直到两指针相遇。但这种方法会改变原表中元素的相对位置。

4. 从有序顺序表中删除其值在给定值 s 与 t 之间（要求 `s<t`）的所有元素，如果 s 或 t 不合理或顺序表为空，则显示出错信息并退出运行。

   - 本题与上一题存在区别，上一题是删除所有值为 x 的元素，而本题是删除值在 s 与 t 之间的所有元素。
   - 先寻找大于等于 s 的第一个元素（第一个要删除的元素）。然后寻找值大于 t 的第一个元素（最后一个删除的元素的下一个元素），要将这段元素删除，只需将后面的元素向前移动。

   ```cpp
   bool Del_s_t2_1(SqList &L,ElemType t){
       // 删除有序顺序表L中所有值在s与t之间的元素
       if(L.length == 0 || s >= t){            // 顺序表为空或s>=t
           return false;                       // 终止操作并返回
       }
       int i = 0;                              // i记录值在s与t之间的元素个数
       while(i < L.length && L.data[i] < s){   // 寻找大于等于s的第一个元素
           i++;
       }
       if(i >= L.length){                      // 顺序表中不存在值在s与t之间的元素
           return false;                       // 终止操作并返回
       }
       int j = i;                              // j记录值大于t的第一个元素
       while(j < L.length && L.data[j] <= t){  // 寻找值大于t的第一个元素
           j++;
       }
       while(j < L.length){                    // 将值大于t的元素向前移动
           L.data[i] = L.data[j];              // 后面的元素向前移动
           i++;
           j++;
       }
       L.length = i;                           // 顺序表长度为i
       return true;                            // 删除成功
   }
   ```

   或者

   ```cpp
   bool Del_s_t2_2(SqList &L,ElemType t){
       int i,k = 0;                            // k记录值在s与t之间的元素个数
       if(L.length == 0 || s >= t){            // 顺序表为空或s>=t
           return false;                       // 终止操作并返回
       }
       for(i = 0; i < L.length && L.data[i] < s; i++); // 寻找大于等于s的第一个元素
           if(L.data[i] >= s && L.data[i] <= t)// 顺序表中不存在值在s与t之间的元素
               k++;                            // k自增
           else
               L.data[i-k] = L.data[i];        // 将值在s与t之间的元素向前移动
       L.length -= k;                          // 顺序表长度减k
       return true;                            // 删除成功
   }
   ```

5. 从顺序表中删除其值在给定值 s 与 t 之间（包含 s 和 t，要求 `s<t`）的所有元素，如果 s 或 t 不合理或顺序表为空，则显示出错信息并退出运行。

   - 算法思想：从前到后遍历顺序表，用 k 记录元素值在 s 与 t 之间的元素个数，初始时 k 为 0，对于当前扫描的元素，若其值不在 s 与 t 之间，则将其前移 k 个位置；否则，执行 k++。
   - 由于这样每个不在 s 到 t 之间的元素仅移动一次，因此算法效率高。

   ```cpp
   bool Del_s_t3(SqList &L,ElemType s,ElemType t){
       // 删除有序顺序表L中所有值在s与t之间的元素
       if(L.length == 0 || s >= t){            // 顺序表为空或s>=t
           return false;                       // 终止操作并返回
       }
       int i,k = 0;                            // k记录值在s与t之间的元素个数
       for(i = 0; i < L.length; i++){          // 遍历顺序表
           if(L.data[i] >= s && L.data[i] <= t)// 找到值在s与t之间的元素
               k++;                            // k自增
           else
               L.data[i-k] = L.data[i];        // 将值在s与t之间的元素向前移动
       }
       L.length -= k;                          // 顺序表长度减k
       return true;                            // 删除成功
   }
   ```

6. 从有序顺序表中删除所有其值重复的元素，使表中所有元素的值均不同。

   - 算法思想：类似直接插入排序，从前到后遍历顺序表，初始时将第一个元素视为无重复元素，之后依次判断后面的元素是否与前面非重复有序表的最后一个元素相同，若相同则继续向后判断，若不同，则插入前面的非重复有序表的最后一个元素之后，直到判断到表尾为止。

   ```cpp
   void Del_same(SqList &L){
       // 删除有序顺序表L中所有重复的元素
       if(L.length == 0){                      // 顺序表为空
           return false;                       // 终止操作并返回
       }
       int i,j;                                // i,j记录遍历顺序表的下标
       for(i = 0,j = 1; j < L.length; j++){    // 遍历顺序表
           if(L.data[i] != L.data[j]){         // 找到不重复的元素
               L.data[++i] = L.data[j];        // 将不重复的元素插入到前面
           }
       }
   }
   ```

   - 如果将有序表改为无序表，使用散列表可以在 `O(n)` 时间内完成

7. 将两个有序顺序表合并为一个新的有序顺序表，并由函数返回结果顺序表。

8. 已知在一维数组 A[m+n] 中依次存放两个线性表 $[a_1,a_2,a_3,...,a_m]$ 和 $[b_1,b_2,b_3,...,b_n]$。编写一个函数，将数组中两个顺序表的位置互换，即将数组中 $[b_1,b_2,b_3,...,b_n]$ 放在 $[a_1,a_2,a_3,...,a_m]$ 前面。

   -

9. 线性表 $(a_1,a_2,a_3,...,a_m)$ 中的元素递增有序且按顺序存储在计算机中。要求设计一个算法，完成用最少的时间在表中查找数值为 x 的元素，若找到，则将其与后继元素位置相交换，若找不到则将其插入表中病逝表中元素仍递增有序。

10. 【2010 统考真题】设将 n $(n>1)$个整数存放到一维数组 R 中，设计一个在时间和空间两方面都尽可能高效的算法，将 R 中保存的序列循环左移 p $(0 < p < n)$ 个位置，即将 R 中的数据由 $(X_0,X_1,...,X_{n-1})$ 变换为$(X_p,X_{p+1},...,X_{n-1},X_0,X_1,...,X_{p-1})$。

11. 【2011 统考真题】一个长度为 L $(L \geq 1)$ 的升序序列 S，处在第 $\frac{L}{2}$ 个位置的数称为 S 的中位数。例如，若序列 $S_1=(11,13,15,17,19)$，则 $S_1$ 的中位数是 15，两个序列的中位数是含它们所有元素的升序序列的中位数。例如，若 $S_2=(2,4,6,8,20)$，则 $S_1$ 和 $S_2$ 的中位数是 11。现在有两个等长升序序列 $A$ 和 $B$，设计一个在时间和空间两方面都尽可能高效的算法，找出两个序列 $A$ 和 $B$ 的中位数。

12. 【2013 统考真题】一直一个整数序列 $A=(a_0,a_1,...,a_{n-1})$，其中 $0 \leq a_i \leq n$。若存在 $a_{p1}=a_{p2}=\cdots=a_{pm}=x$ 且 $m > \frac{n}{2} (0 \leq p_k<n,1\leq k\leq m)$，则称 x 为 A 的主元素。例如，$A=(0,5,5,3,5,7,5,5)$ 中的 5 为主元素；$A=(0,5,5,3,5,1,5,7)$ 中，A 没有主元素。假设 A 中的 n 个元素保存在一个一维数组中，请设计一个尽可能高效的算法，找出 A 的主元素。若存在主元素，则输出该元素；否则输出 -1。要求
    1. 给出算法的基本设计思想。
    2. 根据设计思想，写出代码，关键之处给出解释
    3. 说明你所设计的算法的时间复杂度以及时间复杂度
