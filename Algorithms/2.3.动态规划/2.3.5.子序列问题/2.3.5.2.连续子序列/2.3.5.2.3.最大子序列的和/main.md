# 最大子序和

## 题目链接

[LeetCode](https://leetcode-cn.com/problems/maximum-subarray/)

## 题目描述

给定一个整数数组 `nums` ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。

## 示例

```cpp
示例 1：

输入：nums = [-2,1,-3,4,-1,2,1,-5,4]

输出：6

解释：连续子数组 [4,-1,2,1] 的和最大，为 6 。

```

## 思路：贪心算法

[最大子序和](../../../../2.1.贪心算法/2.1.3有难度/2.1.3.2.最大子序和/main.md#思路贪心算法)

## 思路：动态规划

1. 确定 dp 数组以及下标的含义
   dp[i]：包括下标 i（以 nums[i]为结尾）的最大连续子序列和为 dp[i]。

2. 确定递推公式
   dp[i]只有两个方向可以推出来：

dp[i - 1] + nums[i]，即：nums[i]加入当前连续子序列和
nums[i]，即：从头开始计算当前连续子序列和
一定是取最大的，所以 dp[i] = max(dp[i - 1] + nums[i], nums[i]);

3. dp 数组如何初始化
   从递推公式可以看出来 dp[i]是依赖于 dp[i - 1]的状态，dp[0]就是递推公式的基础。

dp[0]应该是多少呢?

根据 dp[i]的定义，很明显 dp[0]应为 nums[0]即 dp[0] = nums[0]。

4. 确定遍历顺序
   递推公式中 dp[i]依赖于 dp[i - 1]的状态，需要从前向后遍历。

5. 举例推导 dp 数组

| 输入 | -2  | 1   | -3  | 4   | -1  | 2   | 1   | -5  | 4   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| 下标 | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7   | 8   |
| ---- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

| dp[i] | -2  | 1   | -2  | 4   | 3   | 5   | 6   | 1   | 5   |
| ----- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

**注意**：最后的结果并不是最后一个元素，而是 dp 数组中的最大值

### 代码

```cpp
class Solution {
public:
    int maxSubArray(vector<int>& nums) {
        if (nums.size() == 0) return 0;
        vector<int> dp(nums.size());
        dp[0] = nums[0];
        int result = dp[0];
        for (int i = 1; i < nums.size(); i++) {
            dp[i] = max(dp[i - 1] + nums[i], nums[i]); // 状态转移公式
            if (dp[i] > result) result = dp[i]; // result 保存dp[i]的最大值
        }
        return result;
    }
};
```

- 时间复杂度：O(n)
- 空间复杂度：O(n)
