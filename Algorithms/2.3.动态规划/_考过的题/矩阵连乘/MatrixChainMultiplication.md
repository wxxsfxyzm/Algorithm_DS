# 矩阵连乘

## 前置条件

规模为$p×q$的矩阵与规模为$q×r$的矩阵相乘，所需的乘法次数为$pqr$。

## 问题描述

计算矩阵连乘$A_1A_2A_3A_4A_5$，最小需要的计算量是多少?

矩阵维数分别为：30×35、35×15、15×5、5×10、10×20、20×25

将矩阵维数用数组 `dim` 来记录
`int dim[] = { 30, 35, 15, 5, 10, 20, 25 };`
其中矩阵$A_i$的行为`dim[i]`，列为`dim[i+1]`

## 算法思想：

分治法，动态规划

**定义**：

- `dp[i][j]` 表示连乘$A_i ··· A_j$所需的最小计算量
- `s[i][j]` 记录断开的位置，即$A_i$连乘到$A_j$的数乘值最小的位置/加括号的位置

### 递推公式

- 若`i == j`，则`dp[i][j] = 0`
- 若`i < j`，则`dp[i][j] = min{dp[i][k] + dp[k+1][j] + dim[i-1]*dim[k]*dim[j]}`，其中`i <= k < j`

即

$$
dp[i][j] = \begin{cases}
0 & i = j \\
\min_{i \leq k < j} \{ dp[i][k] + dp[k+1][j] + dim[i-1] \cdot dim[k] \cdot dim[j] \} & i < j
\end{cases}
$$

其中，`dp[i][k] + dp[k+1][j]` 表示的是在将两个矩阵链（第 `i` 到第 `k` 个矩阵，和第 `k+1` 到第 `j` 个矩阵）内部的矩阵相乘所需的最小次数之和。这部分是计算两个独立部分的矩阵链乘法所需的最小次数，这两部分各自内部的矩阵乘法是独立完成的，不涉及跨部分的乘法操作。
`dim[i-1]*dim[k]*dim[j]` 是在完成了上述两部分的内部乘法后，需要将这两部分的结果矩阵相乘，以形成从第 `i` 个矩阵到第 `j` 个矩阵的单一连续矩阵链。这一步的乘法次数取决于第 `i-1` 个矩阵的行数、第 `k` 个矩阵的列数（也是第 `k+1` 个矩阵的行数），以及第 `j` 个矩阵的列数。

### dp 数组和 s 数组的计算

1. 第一步
   对角线全为 0，即`dp[i][i] = 0`
   || 0 | 1 | 2 | 3 | 4 | 5 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 0 | 0 | 0 | 0 | 0 | 0 | 0 |
   | 1 | 0 | 0 | 0 | 0 | 0 | 0 |
   | 2 | 0 | 0 | 0 | 0 | 0 | 0 |
   | 3 | 0 | 0 | 0 | 0 | 0 | 0 |
   | 4 | 0 | 0 | 0 | 0 | 0 | 0 |
   | 5 | 0 | 0 | 0 | 0 | 0 | 0 |

2. 第二步
   逐层向上递推，计算`dp[i][j]`，`s[i][j]`的值

   dp 数组：
   || 0 | 1 | 2 | 3 | 4 | 5 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 0 | 0 | 15750 | 7875 | 9375 | 11875 | 15125 |
   | 1 | 0 | 0 | 2625 | 4375 | 7125 | 10500 |
   | 2 | 0 | 0 | 0 | 750 | 2500 | 5375 |
   | 3 | 0 | 0 | 0 | 0 | 1000 | 3500 |
   | 4 | 0 | 0 | 0 | 0 | 0 | 5000 |
   | 5 | 0 | 0 | 0 | 0 | 0 | 0 |

   s 数组：
   || 0 | 1 | 2 | 3 | 4 | 5 |
   |:-:|:-:|:-:|:-:|:-:|:-:|:-:|
   | 0 | 0 | 1 | 1 | 3 | 3 | 3 |
   | 1 | 0 | 0 | 2 | 3 | 3 | 3 |
   | 2 | 0 | 0 | 0 | 3 | 3 | 3 |
   | 3 | 0 | 0 | 0 | 0 | 4 | 5 |
   | 4 | 0 | 0 | 0 | 0 | 0 | 5 |
   | 5 | 0 | 0 | 0 | 0 | 0 | 0 |

### 代码实现

```cpp
#include<iostream>
using namespace std;
const int N = 100;
int A[N];//矩阵规模
int m[N][N];//最优解
int s[N][N];
void MatrixChain(int n)
{
	int r, i, j, k;
	for (i = 0; i <= n; i++)//初始化对角线
	{
		m[i][i] = 0;
	}
	for (r = 2; r <= n; r++)//r个矩阵连乘
	{
		for (i = 1; i <= n - r + 1; i++)//r个矩阵的r-1个空隙中依次测试最优点
		{
			j = i + r - 1;
			m[i][j] = m[i][i]+m[i + 1][j] + A[i - 1] * A[i] * A[j];
			s[i][j] = i;
			for (k = i + 1; k < j; k++)//变换分隔位置，逐一测试
			{
				int t = m[i][k] + m[k + 1][j] + A[i - 1] * A[k] * A[j];
				if (t < m[i][j])//如果变换后的位置更优，则替换原来的分隔方法。
				{
					m[i][j] = t;
					s[i][j] = k;
				}
			}
		}
	}
}
void print(int i, int j)
{
	if (i == j)
	{
		cout << "A[" << i << "]";
		return;
	}
	cout << "(";
	print(i, s[i][j]);
	print(s[i][j] + 1, j);//递归1到s[1][j]
	cout << ")";
}
int main()
{
	int n;//n个矩阵
	cin >> n;
	int i, j;
	for (i = 0; i <= n; i++)
	{
		cin >> A[i];
	}
	MatrixChain(n);
	cout << "最佳添加括号的方式为：";
	print(1, n);
	cout << "\n最小计算量的值为：" << m[1][n] << endl;
	return 0;
}
```
